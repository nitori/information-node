#!/usr/bin/env python3

'''
information-node - an advanced tool for data synchronization
Copyright (C) 2015  information-node Development Team (see AUTHORS.md)

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''

import argparse
import ctypes
import os
import platform
import re
import socket
import sys
import textwrap
import time

from informationnode.daemon.daemon import Daemon
from informationnode.daemon.identity import Identity
from informationnode.helper import check_if_node_dir, check_if_node_runs
from informationnode.helper import DoubleLineBreakFormatter

parser = argparse.ArgumentParser(description=\
    "Tool to create and manage information nodes. "+\
    "This tool is free software. "+\
    "See LICENSE.txt for license and warranty information.",
    formatter_class=DoubleLineBreakFormatter)
action_info_list = [
    ("node", "<node-folder> [<[interface:]port>]",
    "enable the specified node (creates it implicitly)",
    textwrap.dedent('''\
    Enable the given node by
    launching the data server. It handles the gateways and
    allows you to connect the
    viewer, and synchronizes with other connected nodes.
    
    This will create a new information node at the given
    location if it doesn't exist. You should launch the data server with the
    user account that owns the according data folder.

    You can optionally
    allow remote access from other nodes (see "link" below) through the
    specified listen interface - per default, it is disabled.
    ''')),
    ("fingerprint", "<node-folder>",
    "show fingerprint which represents the node's cryptographic identity",
    textwrap.dedent('''\
    Show the fingerprint of the
    node stored at the given folder. This represents the identity of this
    particular node. It is safe to make this information public - it is
    enough to identify a node, but won't allow to decrypt the node's
    data''')),
    ("link", "<target-host[:target-port]>",
    "link to remote node enabled at given interface",
    textwrap.dedent('''\
    Add a connection to a remote
    node. This connection will be continuously attempted to establish by
    the local data server if it fails or breaks up, until you [b]unlink[/b].
    The conneciton is also remembered over data server restarts.

    Please note that unless "allow-read" or "allow-write" (see
    below) was used to enable permissions in any direction, the nodes
    will not be able to share or access any data from each other.''')),
    ("unlink", "<target-host[:target-port]>",
    "unlink from the given remote node",
    textwrap.dedent('''\
    Remove the connection from a remote node again. This will not remove any
    permissions.
    ''')),
    ("allow-read", "<node-folder> <fingerprint> <item-mask>",
    "allow read access for the specified node for the given item mask",
    textwrap.dedent('''\
    Allow the remote node with
    the given fingerprint to access all data in the local node located at
    <node-folder> with read-only permission.

    [b]You can enforce that the target node only gets your data encrypted
    (so you can use it as a backup location that cannot actually access or
    reveal the data)[/b] - see [b]allow-read --help[/b] for details on
    how to do that.

    When another node has read access to items matching a given item
    mask, and this node has write access to that other node, the items
    will automatically get synchronized if the nodes are connected
    (see [b]link[/b]).''')),
    ("disallow-read", "<node-folder> <item-mask> <fingerprint>",
    "disallow read access for the specified node for the given item mask",
    textwrap.dedent('''\
    Revokes read
    access to
    the local node located at <node-folder> for the remote node with the
    given fingerprint.''')),
    ("allow-write", "<node-folder> <item-mask> <fingerprint>",
    "allow write access for the specified node for the given item mask",
    textwrap.dedent('''\
    Allow the
    remote node with
    the given fingerprint to add data to the local node located at
    <node-folder>. Please note this does NOT mean it can also access any
    data - see "allow-read" to allow that.''')),
    ("disallow-write", "<node-folder> <item-mask> <fingerprint>",
    "disallow write access for the specified node for the given item mask",
    textwrap.dedent('''\
    Revokes write access to
    the local node located at <node-folder> for the remote node with the
    given fingerprint.''')),
    ("enable-encrypt-password", "<node-folder> <item-mask> <password>",
    "enable encryption for all items matching the item mask",
    textwrap.dedent('''\
    as soon as any data items arrive which are about to be saved to disk
    which match the given item masks, encrypt it with the given password as
    encryption secret.
    Gateways will still be allowed to process the data once before it gets
    encrypted and stored.

    Please note the password should
    be rather lengthy and random if you want to withstand brute-force
    decryption of an attacker getting somehow access to your encrypted
    information node storage contents on disk. The encryption is set up
    to be asymmetric, so you'll never need to submit the password just to
    start the node later or to add in more encrypted items - it will just
    be required to decrypt items.
    Search performance for such files might generally be considerably
    slower (or for the information node in overall if it contains a large
    amount of such encrypted files).
    [b]SECURITY NOTICE:[/b] some
    very basic metadata like time of creation and moficiation, the item's
    tree path
    (which is matched against the item mask), a random id and what the
    item is (file, message, ...)
    will still remain unencrypted for each data part to enable the
    syncing protocol
    to operate properly.
    The actual filename or the message conversation targets or of course the
    contents will be encrypted and hidden.
    ''')),
    ("disable-encrypt-password", "<node-folder> <item-mask> <password>",
    "disable encryption for all items matching the item mask",
    textwrap.dedent('''\
    Disable the encryption with a password again. Please note decryption
    all the items might take some time, so this command can take a while
    to complete. If the information node is terminated before this command
    completes, simply issue it again to make sure everything is decrypted.
    ''')),
    ("enable-encrypt-target-node", "<node-folder> <fingerprint> <cert>",
    "enable encryption only decryptable by the specified target node's "+\
        "cryptographic identity. " +\
        "Read the detailed command help!",
    textwrap.dedent('''\
    As soon as any data arrives at this node from another node or from
    an information gateway, encrypt it before it gets written to disk
    in a way that allows decryption only with the private key
    information possessed and stored
    with the target node identified by <fingerprint> (which can run on any
    other computer in this world - and doesn't need to be directly
    linked).
    Gateways will still be allowed to process the data once before it gets
    encrypted and stored.
    The node can and will still share the data with others according to
    the specified read/write access and remote links, but no node
    including
    this node itself will be able to decrypt the contents.
    Only if the specified target node ever obtains them, it will be
    able to decrypt and actually read it.
    The <cert> file needs to be obtained and provided manually from the
    given target node (where it can be exported with [b]export-cert[/b])
    for technical reasons - it will be verified to match
    the fingerprint, so it should be safe to obtain it over insecure
    ways if you need to. Publishing the <cert> file won't give an attacker
    access to the data - however, publishing the file system contents of
    the target node's local storage folder will.
    [b]SECURITY NOTICE:[/b] some
    very basic metadata like time of creation and a random id
    will still remain unencrypted for each data part to enable the
    syncing protocol
    to operate properly.''')),
    ("disable-encrypt-target-node", "<node-folder> <item-mask>",
    "disable encryption of given items for the given target node",
    textwrap.dedent('''\
    Disables the target node encryption - but only for newly added
    tems. This is because only the target node has the information to
    decrypt anything again, so it is impossible for this node to do this.
    Only if there is a sychronization from the target node for the
    encryption to this
    one, the files will be gradually synchronized back to an unencrypted
    state at this node.''')),
    ("enable-gateway", "<node-folder> <gateway-name> <gateway-options>",
    "enable the given gateway which syncs data items in/out of the " +\
        "node to e.g. a folder on disk you can access like dropbox, "+\
        "your e-mail or similar",
    textwrap.dedent('''\
    Enable an automated gateway and provide the given set of
    options which are
    gateway specific. For the options, see [b]gateway-usage[/b].
    For a list of all possible gateways, see [b]gateway-list[/b].
    If you don't specify any options and the gateway had already been
    running, it will relaunch with the last specified set of options.
    [b]SECURITY NOTICE:[/b] the options will
    be stored inside the <node-folder> location [b]including
    passwords[/b] as plain text which some gateways require.
    To wipe that info, see [b]remove-gateway[/b].''')),
    ("gateway-list", "",
    "list all available gateways",
    textwrap.dedent('''\
    A list of the names of all available gateways.
    Use "gateway-info" below for details on a specific gateway.''')), 
    ("gateway-usage", "<gateway-name>",
    "show usage info for this gateway",
    textwrap.dedent('''\
    Print out what the gateway with this name does, how it works and
    what options it takes for [b]enable-gateway[/b].''')),
    ("gateway-status", "<node-folder> [gateway]",
    "show info about a gateway's status on this node",
    textwrap.dedent('''\
    Show the status of all the running gateways at the given node (or
    with more details for the specific one with the given gateway name,
    if given).''')),
    ("disable-gateway", "<node-folder> <gateway-name>",
    "disable given gateway temporarily (keeps option data)",
    textwrap.dedent('''\
    Temporarily
    disable a gateway - this will still keep the last used options stored.
    To get rid of all traces of a gateway, use [b]forget-gateway[/b].''')),
    ("forget-gateway", "<node-folder> <gateway-name>",
    "disables given gateway completely including an option data wipe",
    textwrap.dedent('''\
    Disable the
    given gateway if enabled, and then wipe all stored options data.''')),
    ("export-cert", "<node-folder> <file-to-write-to>",
    "export the certificate of this node which allows others "+\
        "to encrypt specifically for this node",
    textwrap.dedent('''\
    Export the certificate file required for [b]encrypt-for-target[/b].
    This file can be verified with the fingerprint and it doesn't allow
    to decrypt anything, so it's rather safe to pass around.
    It will allow another node to encrypt data that can only be encrypted
    by this node - see [b]enable-encrypt-target-node[/b].''')),
    ("export-identity", "<node-folder> <file-to-write-to> <passphrase>",
    "export cryptographic identity - DANGEROUS. See detailed help",
    textwrap.dedent('''\
    [b]READ CAREFULLY![/b] This exports the
    cryptographic data representing this node (beyond the fingerprint).
    You should only ever require this to backup a node which needs to
    decrypt files.
    You will NEVER need this to let other nodes know how to encrypt things
    for you, and it should never be anywhere else than a secure place and
    this node's own machine.
    You should only
    store this identity data in some safe location!
    (e.g. print it out, the file
    is readable text and not that long!)
    You are required to specify a password to encrypt it. It is recommended
    you choose a very strong password if you ever store it in a possibly
    unsafe location.
    [b]SECURITY NOTICE:[/b] This data allows you to decrypt whatever only
    this node could decrypt as per [b]encrypt-for-target[/b] and it allows
    completely impersonating this node in all communication - therefore,
    this data is [b]very sensitive[/b].''')),
    ("import-identity", "<node-folder> <file-to-import> <passphrase>",
    "re-import a cryptographic identity from a backup",
    textwrap.dedent('''\
    Import the exported identity into the node stored at the given
    location (with the given decryption passphrase for the identity file).
    This is useful if you want to back it up to ensure you will always be
    able to decrypt data encrypted for this node only stored in other nodes,
    even when this node's contents and identity are lost e.g. in a disk crash.

    This import will wipe the node's previous identity, which means that its
    fingerprint will change.
    [b]POTENTIAL DATA LOSS NOTICE:[/b]
    All data will be kept, but if the node was
    previously the only one to be able to decrypt some specific data of
    [b]encrypt-for-target[/b], it will now [b]no longer be able to do so
    since that capability is linked with this cryptographic identity.[/b]'''
    )),
]

# make a nice access dictionary of the action info:
action_info = {}
for action in action_info_list:
    action_info[action[0]] = (action[0], action[1], action[2], action[3])

def get_action_overall_help_text():
    text = "Specify one of those possible actions to be executed:"
    for action in action_info_list:
        text += "\n\n[b]\"" + action[0] + "\" " + action[1] +\
            "[/b] - " +\
            action[2] + ("." if (not action[2].endswith(".") and \
                not action[2].endswith("!") and \
                not action[2].endswith("?")) else "") + \
            " For " +\
            "more details, try: ./information-node " + str(action[0]) +\
            " --help"
    return text

faq_text = textwrap.dedent('''\
    Information nodes are managed with those tools:

    * [b]inode-viewer[/b]: this is the graphical application which assists
        in creating, managing and browsing a node. Use this if you don't
        want to learn the detailed tools.

    * [b]information-node[/b]: the management tool for creating and managing
        nodes. It doesn't concern itself with the actual concrete data
        contents of a node, use either the graphical viewer or
        inode-viewer-cli for that.

    * [b]inode-viewer-cli[/b]: simple command line tool to directly list and
        extract or modify the actual data items contained in a node. Only
        for advanced usage or scripts, you would normally want to use either
        the graphical viewer or a gateway.

    Everything the graphical viewer does can be done using either
    information-node or inode-viewer-cli as well.

    [b]== What is an information node? ==[/b]

    Information nodes simply store
    data and share it amongst themselves when linked with each other
    over encrypted connections
    according
    to specified read/write access rules. This creates
    an autonomous data sharing cloud, similar to e.g.
    syncthing or Dropbox.

    [b]== Why should I use this? ==[/b]

    - You want something like Dropbox or Syncthing but also for your messages
      and e-mails and not just files

    - You don't like using proprietary non-free tools

    - You want automatic remote backup locations which can be secured with
      strong encryption

    [b]== What sort of data does an information node store? ==[/b]

    Nodes are meant to store any sort of data you might have, like
    e-mail, Instant Messaging, personal file cloud etc. Unlike
    other synchronisation tools like rsync, dropbox, syncthing,
    seafile, .. it is NOT specifically limited
    to files only but includes abstract objects that can also
    model messages/e-mails/.. and tools to manage them.

    [b]== Where is the data of a node stored? ==[/b]

    It is all stored in the given node folder (see commands below).
    The storage is a sort of black box optimized for performance, so
    you cannot trivially browse the files similar to Dropbox or syncthing.
    If you want to look at it you'll either need to use the inode-viewer
    or set up a file gateway to a regular folder (which mimics a Dropbox
    setup).

    Nothing is stored outside the node folder except some basic preferences
    for the graphical node contents viewer if you use that one.
    The data is only shared exactly in the fashion specified by
    you, and if you want also encrypted inside the node's internal storage.

    [b]== How do I get my e-mails into this thing easily? ==[/b]

    To use an information node as automated communication relay with
    regular protocols (e-mail, IM), look at [b]enable-gateway[/b] below
    which allows an information node to be used as an [b]e-mail client[/b],
    [b]XMPP chat client[/b] and much more. (the inode-viewer can assist you
    with this as well.)
    Remember, you can always sync everything with other nodes too, and
    look and interact with it using the viewer.
    A file gateway also allows you to map your files to a regular
    folder on your disk to have your own private dropbox/syncthing/btsync
    equivalent.

    [b]== Is this system secure against data thieves? ==[/b]

    This depends. [b]encrypt-password[/b] data will be as secure as your
    chosen password is, when subject to a brute force attack.
    (and trojans could sniff the password when you enter it in the viewer
    to look at the data yourself, so make sure your machine is clean)
    [b]encrypt-for-node[/b] data will be hardened with RSA/AES and will
    be rather hard to steal and decrypt - unless an attacker gets their
    hands on the node directory contents of the [b]target node[/b] (the
    node which can decrypt it with its cryptographic identity), in which
    case it'll be trivial to open up. It is therefore as safe as the
    respective target node is kept.

    But always remember, [b]one rogue node[/b] with write access can
    do a lot of damage. (even with read access when it steals your data)
    In the end, this software can also always have bugs. The code is
    open-source, if you have the knowledge please help review and secure
    it.

    [b]== What happens in case of data loss (dead hard disk etc.)? ==[/b]

    There is versioning support (configurable through the client) which
    should help a bit against file corruption if you notice it
    early enough.
    If a node suffers sudden catastrophic failure, you should be fine if
    you had the data distributed to at least one other node.
    If you fear you will lose the only node
    being able to decrypt some of your data as per
    [b]encrypt-for-target[/b], use [b]export-identity[/b] (see below)
    to backup its private key.

    But don't forget, this software can have bugs which might also cause
    data loss of any sort.

    [b]== How do I get started? ==[/b]

    Create a node (see the action [b]"node"[/b] below), then
    get connected to it with [b]information-node-viewer[/b].
    The viewer will also assist you setting up
    gateways to interface with IMAP, a folder like dropbox, ..
    Later on, add and link remote nodes as you see fit.
    ''') 

def print_faq():
    print("This is a comprehensive FAQ on information nodes:")
    print("")
    t = DoubleLineBreakFormatter._static_fill_text(faq_text, 78, "   ")
    print(t)
    print("")
    print("ALWAYS REMEMBER, nothing is perfectly safe. USE AT YOUR OWN RISK.")
    print("If you have more questions, don't hesitate to seek " +\
        "contact at:\n  https://github.com/JonasT/information-node")
 
parser.add_argument("action",
    help=get_action_overall_help_text())
parser.add_argument("--faq",
    default=False, action="store_true",
    help="display a basic FAQ explaining how this tool is useful, " +\
        "what you should use it for and what not")
parser.add_argument("argument", nargs="*",
    help="argument(s) to given action as specified above")

# display usage if there are literally no arguments at all:
if len(" ".join(sys.argv[1:]).strip()) == 0:
    parser.print_usage()
    sys.exit(1)

# show faq if --faq is used:
for arg in sys.argv[1:]:
    if arg == "--":
        break
    if arg == "--faq":
        print_faq()
        sys.exit(0)

# extract all arguments not meant for a subcommand:
main_args = []
subcmd_args = []
for arg in sys.argv[1:]:
    if not arg.startswith("-"):
        main_args.append(arg)
        subcmd_args = sys.argv[1 + len(main_args):]
        break
    main_args.append(arg)
args = parser.parse_args(main_args)

# print faq if specified somewhere in the later args:
if args.faq:
    print_faq()
    sys.exit(0)

try:
    from Crypto.PublicKey import RSA
except ImportError:
    print("information-node: error: PyCrypto is not available. "+\
        "Please install it for Python 3 and try again.")
    sys.exit(1)

if args.action == "node":
    subparser = argparse.ArgumentParser(prog=\
        os.path.basename(sys.argv[0]) + " node", description=\
        action_info["node"][3],
        formatter_class=DoubleLineBreakFormatter)
    subparser.add_argument("node-folder",
        help="the location where the node is stored or should be created at")
    subparser.add_argument("interface[:port]", nargs="?", default="",
        help="interface to listen at for remote connections "+\
            "for links (optional)")
    subparser.add_argument("--foreground", default=False,
        action='store_true',
        help="don't daemonize the data server and run it in another "+\
            "thread/process. Instead, run it in this terminal in foreground")
    args = subparser.parse_args(subcmd_args)
    setattr(args, "node_folder", getattr(args, "node-folder"))
    setattr(args, "interface", getattr(args, "interface[:port]"))

    # get interface info:
    interface_info = ""
    if len(args.interface) > 0:
        interface_info = args.interface

    # see if interface info is valid:
    listen_ip = "::0"
    listen_port = 38950
    if len(interface_info) > 0:
        colon_pos = interface_info.rfind(":")
        ip_part = ""
        port = None
        if colon_pos < 0:
            if interface_info.find(".") < 0:
                print("information-node: error: supplied listen interface "+\
                    "is not a valid ip address", file=sys.stderr)
                sys.exit(1)
            ip_part = interface_info
        else:
            port_str = None
            if interface_info.find(":") != colon_pos:
                # must be ipv6. verify proper square brackets:
                if (not interface_info[0] == "[") or \
                        (not interface_info[colon_pos - 1] == "]"):
                    # not []: but maybe it's [..:..:..]?
                    if not interface_info.endswith("]"):
                        print("information-node: error: supplied listen " +\
                            "interface is not a valid ip address - did you "+\
                            "use square brackets for ipv6?", file=sys.stderr)
                        sys.exit(1)
                    ip_part = interface_info[1:-1]
                else:
                    ip_part = interface_info[1:colon_pos - 1]
                    port_str = interface_info[colon_pos + 1:]
            else:
                ip_part = interface_info[0:colon_pos]
                port_str = interface_info[colon_pos + 1:]
            if port_str != None:
                try:
                    port = int(port_str)
                except ValueError:
                    print("information-node: error: supplied listen " +\
                        "interface has invalid port - not a number",\
                        file=sys.stderr)
                    sys.exit(1)
        # ok, check if this is a valid ip and port range:
        if port != None and (port < 1 or port > 65535):
            print("information-node: error: supplied listen interface " +\
                "has invalid port - exceeds valid port range",
                file=sys.stderr) 
            sys.exit(1)

        # check for valid ip:
        try:
            import ipaddress
            adr = ipaddress.ip_address(ip_part)
        except ValueError:
            print("information-node: error: supplied listen interface "+\
                "has invalid address - not a valid IP address",
                file=sys.stderr)
            sys.exit(1)

        listen_ip = ip_part
        if port != None:
            listen_port = port

    node_folder = args.node_folder

    # check if node directory is valid:
    (result, msg) = check_if_node_dir(node_folder, allow_new=True)
    if result != True:
        print("information-node: error: " + msg, file=sys.stderr)
        sys.exit(1)
         
    # check if node dir is empty and we need to initialise it:
    if len(os.listdir(node_folder)) == 0:
        print("information-node: info: " +\
            "creating new information node at location " +\
            node_folder + "...")

        # create item storage directory:
        os.mkdir(os.path.join(node_folder, "storage"))

        # create and store a new identity:
        identity = Identity()
        identity.save_to_file(os.path.join(node_folder, "identity.secret"))

        # create log directory:
        os.mkdir(os.path.join(node_folder, "logs"))

    # check if pid file exists:
    (result, msg) = check_if_node_runs(node_folder) 
    if result == None:
        print("information-node: error: " + msg, file=sys.stderr)
        sys.exit(1)
    if result:
        print("information-node: info: data server for this node is " +\
            "running with pid " + str(msg))
        print("information-node: info: nothing to do.")
        sys.exit(0)

    print("information-node: info: " +\
        "preparing communications socket for daemon...")

    # on unix, create api file socket at this point (for viewer access):
    if platform.system().lower() != "windows":
        if os.path.exists(os.path.join(node_folder, "api_access.sock")):
            print("information-node: warning: removing stale file socket",
                file=sys.stderr)
            os.remove(os.path.join(node_folder, "api_access.sock"))
        api_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        api_socket.bind(os.path.join(node_folder, "api_access.sock"))

    # on windows, open up api socket at any port, and write port to file:
    if platform.system().lower() == "windows" and args.foreground:
        api_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        api_socket.bind(("::0", 0))
        port = api_socket.getsockname()[1]
        f = open(os.path.join(node_folder, "api_access.port"), "wb")
        f.write(str(port).encode("utf8", "ignore"))
        f.close()

    # a helper function to wait until a pidfile was made:
    def wait_for_pid_file():
        while True:
            if not os.path.exists(os.path.join(node_folder, "pidfile")):
                time.sleep(0.5)
            else:
                break

    # handle daemonizing:
    print("information-node: info: launching information-node daemon...")
    if platform.system().lower() == "windows":
        # on windows we cannot fork, so we need to run ourselves again as
        # a new detached process (unless we _are_ that detached process):
        if not args.foreground:
            DETACHED_PROCESS = 8
            subprocess.Popen([sys.executable, __file__, 
                "node", "--foreground", node_folder],
                creationflags=DETACHED_PROCESS,
                close_fds=True)
            wait_for_pid_file()
            print("information-node: info: data server is running!")
            sys.exit(0)
    else:
        # this should be a unix system:
        # fork should be available and work as expected. -> fork
        if not args.foreground:
            try:
                pid = os.fork()
                if pid > 0:
                    # this is the parent process. exit:
                    wait_for_pid_file()
                    print("information-node: info: data server is running!")
                    sys.exit(0)
            except OSError as e:
                print("information-node: error: fork failed.", file=sys.stderr)
                sys.exit(1)
            # disable stdin/stdout:
            devnull = [os.open(os.devnull, os.O_RDWR) for x in [1, 2]]
            os.dup2(devnull[0], 1)
            os.dup2(devnull[1], 2)

    # create a pid file:
    pid_bytes = str(os.getpid()).encode("utf-8", "ignore")
    f = open(os.path.join(node_folder, "pidfile"), "wb")
    f.write(pid_bytes)
    f.close()

    # if we arrive here, we are in the daemon process/thread. run daemon:
    Daemon().run(api_socket)
else:
    if args.action in action_info:
        print("Dear user,")
        print("")
        print("This software is still \033[1mwork in progress\033[21m.\n"+\
            "Sadly, this action is \033[1mnot available yet\033[21m" +\
            " in this version.")
        print("")
        print("Best regards,\nThe developers")
        print("")
        print("information-node: error: action UNIMPLEMENTED: " + args.action,
            file=sys.stderr)
        sys.exit(1)
    print("information-node: error: unknown action: " + args.action,
        file=sys.stderr)


